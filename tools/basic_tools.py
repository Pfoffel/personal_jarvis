import os
from structure_schema.basic_structures import SaveFile
from langchain.tools import tool

@tool(args_schema=SaveFile)
def save_output(file_name: str, content: str, category: str, file_type: str, sub_folder: str = None) -> str:
    """ Saves the output generated by the LLM into corresponding folders, depending on it's category 
    Arguments are:
    - file_name: name of the file without extension (no dot)
    - content: the str content that should be written to the file
    - category: the category it should create this file in
    - file_type: the extention of the file without the dot
    """
    # Base directory where all files are stored
    base_dir = "outputs"

    # Construct full path
    target_dir = os.path.join(base_dir, category.lower(), sub_folder.lower() if sub_folder else None)

    # Ensure directory exists
    os.makedirs(target_dir, exist_ok=True)

    # Full file path
    file_path = os.path.join(target_dir, f"{file_name}.{file_type}")

    # Save content to file
    try: 
        with open(file_path, 'w') as f:
            f.write(content)
    except Exception as e:
        return f"Error Occured: {e}"
        
    return f"File saved to: {file_path}"

@tool
def list_files():
    """ Returns a dictionary with file names as keys and their relative paths as values.
    Traverses all subdirectories. """

    search_folder = "outputs"
    file_dict = {}
    for root, _, files in os.walk(search_folder):
        for file in files:
            relative_path = os.path.relpath(os.path.join(root, file), search_folder)
            file_dict[file] = f"{search_folder}\\{relative_path}"
    return file_dict

@tool
def load_file_content(path: str) -> str:
    """ loads the files content as a str given the path to it"""
    try:
        with open(path, "r") as f:
            return f.read()
    except Exception as e:
        return f"Error Occurred when reading file: {e}"

@tool
def open_files(path: str) -> str:
    """ open the file found in the given path for the user so he doens't have to find it manually """
    try:
        os.startfile(path)
        return "File opening for user."
    except Exception as e:
        return f"Error Occurred when opening file: {e}"

def load_output_files():
    """ Returns a dictionary with file names as keys and their relative paths as values.
    Traverses all subdirectories. """

    search_folder = "outputs"
    file_dict = {}
    for root, _, files in os.walk(search_folder):
        for file in files:
            relative_path = os.path.relpath(os.path.join(root, file), search_folder)
            file_dict[file] = f"{search_folder}\\{relative_path}"
    return file_dict

if __name__ == "__main__":
    print(list_files())