import os
from structure_schema.basic_structures import SaveFile
from langchain.tools import tool

@tool(args_schema=SaveFile)
def save_output(file_name: str, content: str, category: str, file_type: str, sub_folder: str = None) -> str:
    """ Saves the output generated by the LLM into corresponding folders, depending on it's category 
    Arguments are:
    - file_name: name of the file without extension (no dot)
    - content: the str content that should be written to the file
    - category: the category it should create this file in
    - file_type: the extention of the file without the dot
    """
    # Base directory where all files are stored
    base_dir = "outputs"

    # Construct full path
    target_dir = os.path.join(base_dir, category.lower(), sub_folder.lower() if sub_folder else None)

    # Ensure directory exists
    os.makedirs(target_dir, exist_ok=True)

    # Full file path
    file_path = os.path.join(target_dir, f"{file_name}.{file_type}")

    # Save content to file
    try: 
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
    except Exception as e:
        return f"Error Occured: {e}"
        
    return f"File saved to: {file_path}"

@tool
def list_files():
    """ Returns a dictionary with file names as keys and their relative paths as values.
    Traverses all subdirectories. """

    search_folder = "outputs"
    file_dict = {}
    for root, _, files in os.walk(search_folder):
        for file in files:
            relative_path = os.path.relpath(os.path.join(root, file), search_folder)
            file_dict[file] = f"{search_folder}\\{relative_path}"
    return file_dict

@tool
def load_file_content(path: str) -> str:
    """ loads the files content as a str given the path to it"""
    try:
        with open(path, "r") as f:
            return f.read()
    except Exception as e:
        return f"Error Occurred when reading file: {e}"

@tool
def open_files(path: str) -> str:
    """ open the file found in the given path for the user so he doens't have to find it manually """
    try:
        os.startfile(path)
        return "File opening for user."
    except Exception as e:
        return f"Error Occurred when opening file: {e}"

@tool
def delete_local_file(file_path: str) -> str:
    """Deletes a local file given its path.

    Args:
        file_path (str): The absolute or relative path to the local file to be deleted.
                         For safety, it's recommended to use paths relative to a known directory like 'outputs'.

    Returns:
        str: A confirmation message if deletion is successful, or an error message if it fails.
    """
    try:
        if not os.path.exists(file_path):
            return f"Error: File not found at path: {file_path}"
        if not os.path.isfile(file_path): # Check if it's a file, not a directory
            return f"Error: Path exists but is not a file: {file_path}. This tool can only delete files."

        os.remove(file_path)
        return f"Successfully deleted file: {file_path}"
    except FileNotFoundError: # Should be caught by os.path.exists, but as a safeguard
        return f"Error: File not found at path: {file_path}"
    except PermissionError:
        return f"Error: Permission denied to delete file: {file_path}"
    except OSError as e: # Catches issues like file in use or trying to delete a directory on some OS
        return f"Error deleting file: {e}. (Ensure it's not a directory and is not in use)"
    except Exception as e:
        return f"An unexpected error occurred: {e}"

def load_output_files():
    """ Returns a dictionary with file names as keys and their relative paths as values.
    Traverses all subdirectories. """

    search_folder = "outputs"
    file_dict = {}
    for root, _, files in os.walk(search_folder):
        for file in files:
            relative_path = os.path.relpath(os.path.join(root, file), search_folder)
            file_dict[file] = f"{search_folder}\\{relative_path}"
    return file_dict

if __name__ == "__main__":
    print(list_files())